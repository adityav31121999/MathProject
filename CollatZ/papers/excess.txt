
// Collatz Series and Steps 
#include <iostream>
#include <cmath>
#include <vector>
#include <numeric>
#include <functional>
#include <filesystem>


/**
 * @brief Compute the Collatz sequence for a single number
 * @param[in] input the input number
 * @return a vector of numbers representing the Collatz sequence
 */
std::vector<long long int> collatzseq(long long int input) {
	std::vector<long long int> seq;
	seq.push_back(input);
	while (input != 1) {
		// if the number is even, divide it by 2
		if (input % 2 == 0)
			input /= 2;
		// if the number is odd, multiply it by 3 and add 1
		else
			input = 3 * input + 1;
		seq.push_back(input);
	}
	return seq;
}


int stopping(long long int input) {
	int steps = 0;
	long long int n = input;
	while (1) {
		if (n > 1) {
			if (n % 2 == 0)
				n /= 2;
			else
				n = 3 * n + 1;
			steps++;
		}
		else
			break;
	}
	return steps;
}


/**
 * @brief Compute Stopping time of Collatz sequence for a range of numbers
 * @param[in] lim1 lower limit of the range
 * @param[in] lim2 upper limit of the range
 * @return a vector of pairs where each pair contains the number and
 *         the number of steps to reach 1
 */
std::vector<std::pair<long long int, int>> collatzsteps(long long int lim1, long long int lim2) {
	std::vector<std::pair<long long int, int>> csteps;
	for (long long int i = lim1; i <= lim2; i++) {
		long long int n = i;
		int steps = 0;
		// Compute the Collatz sequence for the number
		while (n != 1) {
			if (n % 2 == 0)
				n /= 2; // if n is even, divide it by 2
			else
				n = 3 * n + 1; // if n is odd, multiply it by 3 and add 1
			steps++; // increment the number of steps
		}
		// Store the number and the number of steps
		csteps.push_back({ i, steps });
	}
	return csteps;
}

-----------------------------------

#include <iostream>
#include <cmath>
#include <vector>
#include <numeric>
#include <functional>
#include <filesystem>


/**
 * @brief Compute the kth term of the Collatz sequence for a given starting value R
 *        This function takes a list of positions and a value from a base stem, and computes
 *        the kth term of the Collatz sequence starting from the given value. The function
 *        works by flipping the bits at the given positions and then computing the next
 *        term in the sequence. If the value is 1, the function returns 0.
 * @param[in] positions the positions of the bits to flip
 * @param[in] k the kth term to compute
 * @param[in] Rvalue value from base stem
 * @return the kth term of the sequence
 */
long long int generateterm(std::vector<int> positions, long long int k, long long int Rvalue) {
    // Compute the kth term of the sequence
    if ((Rvalue - 1) % 9 == 0) {
        std::cerr << "Branchless Stem Value -_-" << std::endl;
        return (Rvalue - 1) / 3;
    }

    // calculate the first node
    long long int t = (Rvalue - 1) / 3;

    // Loop until we reach the kth term
    for (int i = 0; i < k; i++) {
        // Flip the bit at position i to compute the next term
        t = (t * std::pow(2, positions[i]) - 1) / 3;
        /*
        if ((t - 1) % 9 == 0) {
            t = (t - 1) / 3;
            break;
        }
        */
    }
    return t;
}

---------------------------------

/**
 * --------------------------------------------------:checktheory:--------------------------------------------------
 * This process involves the calculation of the Nodes of Collatz Conjecture.
 * - By using the division ladder equation, calculate node values of the collatz tree.
 * - For this, first take certain numbre of values in a vector, this is position vector.
 * - This vector will be used in calculatiing powers of 2.
 * - Get a base stem value which is of even power and also power should be larger than 3.
 * - If this value is divisible by 9, then this is not valid. Return 0.
 * - On next step, perform the operations as per division ladder.
 * - If any value T*2^n -1 is divisible by 9, then this is not valid. Return 0.
 * - If all the values are valid, return the node value.
 * 
 * For cecking theory and finding a patter:
 * - Get a vector of numebrs/positions
 * - Perform permutations on positions, and store in 2D vector.
 * - Operate using above process and store values along with positions 
 * - Use another function to check whether the obtained values are correct or not
 * - This function will calculate whether all the values involved are correct or not
 * - Return the vector
 */

#include <vector>
#include <iostream>
#include <algorithm>
#include <numeric>


/**
 * @brief verification of the division ladder equation
 * @param[in] p position vector
 * @param[in] r base stem value
 * @return vector of node values
 */
std::vector<std::vector<long long int>> checktheory(std::vector<long long int> p, int r) {
    // check for base stem
    if((r-1)%9 == 0)
        return {{0}};

    // number of permutations and nodes to be traversed
    int k = p.size();
    int permutes = 1;
    for (int i = 0; i < k; i++)
        permutes *= i;

    // holds permutation
    std::vector<std::vector<long long int>> ps(permutes, std::vector<long long int>(k, 0));
    // hold result
    std::vector<std::vector<long long int>> c(permutes, std::vector<long long int>(k+1, 0));

    // sort original vector for positions
    std::sort(p.begin(), p.end());
    // run for permutations and also calculate nodes
    do {
        // allot permutation of p to ps
        ps[permutes-1] = p;
        // hold first node
        long long int t = (r - 1) / 3;

        // Loop until we reach the kth term
        for (int i = 0; i < k; i++) {
            // Flip the bit at position i to compute the next term
            t = t * std::pow(2, p[i]);
            if((t-1)%9 == 0)
                break;
            c[permutes][i] = i; 
            t = (t - 1) / 3;
        }

        // Store the node
        c[permutes][k] = t;
        permutes--;
    } while (std::next_permutation(p.begin(), p.end()));
    
    return c;
}


/**
 * @brief Check if a given node is valid according to the Collatz
 *        Conjecture.
 * @param[in] node the node to check
 * @return a vector of positions of the bits to flip in the division
 *         ladder to get the next node in the sequence. If the node is
 *         invalid, the function returns an empty vector.
 */
std::vector<long long int> checkpositions(int node) {
    std::vector<long long int> p;
    while(node != 1) {
        // 2^n = 3node + 1 => log2(3node + 1) = n => pushback n
        node = 3*node + 1; // make it even
        int count = 0;
        while(node%2 == 0) {
            count++;
            node = node/2;  // divide by 2 and continue incrementing count
        }
        p.push_back(count); // pushback count in vector
    }
    if (p.size() == 0)
        return p;

    int rvalue = std::pow(2, p[p.size() - 1]);
    // reverse the vector this gives original vector
    std::reverse(p.begin(), p.end());
    p[0] = rvalue;
    return p;
}


/**
 * @brief verification of the division ladder equation
 * @param[in] p position vector
 * @param[in] r base stem value
 * @return vector of node values
 */
std::vector<std::vector<long long int>> verifytheory(std::vector<long long int> p, long long int r) {
    // check for base stem
    if ((r - 1) % 9 == 0)
        return { {0} };

    // number of permutations and nodes to be traversed
    int k = p.size();
    int permutes = 1;
    for (int i = 0; i < k; i++)
        permutes *= i;

    // holds permutation
    std::vector<std::vector<long long int>> ps;
    // hold result
    std::vector<std::vector<long long int>> c;

    // holds all the values required for cross checking and verification
    std::vector<std::vector<long long int>> check;

    // sort original vector for positions
    std::sort(p.begin(), p.end());
    // run for permutations and also calculate nodes
    do {
        // allot permutation of p to ps
        ps[permutes - 1] = p;
        // hold first node
        long long int t = (r - 1) / 3;

        // Loop until we reach the kth term
        for (int i = 0; i < k; i++) {
            // Flip the bit at position i to compute the next term
            t = t * std::pow(2, p[i]);
            if ((t - 1) % 9 == 0) {
                c[permutes].push_back(i);
                t = (t - 1) / 3;
                break;
            }
            c[permutes].push_back(i);
            t = (t - 1) / 3;
        }

        // Store the node
        c[permutes].push_back(t);
        // add a 0 as separator
        c[permutes].push_back(0);

        std::vector<long long int> p;
        while (t != 1) {
            // 2^n = 3node + 1 => log2(3node + 1) = n => pushback n
            t = 3 * t + 1; // make it even
            int count = 0;
            while (t % 2 == 0) {
                count++;
                t = t / 2;  // divide by 2 and continue incrementing count
            }
            p.push_back(count); // pushback count in vector
        }

        int rvalue = std::pow(2, p[p.size() - 1]);
        // reverse the vector this gives original vector
        std::reverse(p.begin(), p.end());

        // add this to vector c[permute]
        c[permutes].insert(c[permutes].end(), p.begin(), p.end());

        permutes--;
    } while (std::next_permutation(p.begin(), p.end()));

    // reassign permutes its value
    for (int i = 0; i < k; i++)
        permutes *= i;

    // print all values
    for (int i = 0; i < permutes; i++) {
        // first position vector
        for (int j = 0; j < k+1; j++) {
            std::cout << check[i][j] << "    ";
        }
        std::cout << "    |    ";
        for (int j = k+1; j < 2*k+2; j++) {
            std::cout << check[i][j] << "    ";
        }
    }

    return c;
}

---------------------------------


#include <iostream>
#include <cmath>
#include <vector>
#include <numeric>
#include <functional>
#include <filesystem>


/**
 * @brief Compute the kth term of the Collatz sequence for a given starting value R
 *        This function takes a list of positions and a value from a base stem, and computes
 *        the kth term of the Collatz sequence starting from the given value. The function
 *        works by flipping the bits at the given positions and then computing the next
 *        term in the sequence. If the value is 1, the function returns 0.
 * @param[in] positions the positions of the bits to flip
 * @param[in] k the kth term to compute
 * @param[in] Rvalue value from base stem
 * @return the kth term of the sequence
 */
long long int generateterm(std::vector<int> positions, long long int k, long long int Rvalue) {
    // Compute the kth term of the sequence
    if ((Rvalue - 1) % 9 == 0) {
        std::cerr << "Branchless Stem Value -_-" << std::endl;
        return (Rvalue - 1) / 3;
    }

    // calculate the first node
    long long int t = (Rvalue - 1) / 3;

    // Loop until we reach the kth term
    for (int i = 0; i < k; i++) {
        // Flip the bit at position i to compute the next term
        t = (t * std::pow(2, positions[i]) - 1) / 3;
        /*
        if ((t - 1) % 9 == 0) {
            t = (t - 1) / 3;
            break;
        }
        */
    }
    return t;
}



/**
 * @brief verification of the division ladder equation for collatz conjecture
 * @param[in] p position vector
 * @param[in] r base stem value
 * @return vector of node values
 */
int verifytheory(std::vector<int> p, int r) {
    std::vector<std::vector<int>> check;
    // check for base stem
    if ((r - 1) % 9 == 0 || (r-1)%3 != 0) {
        std::cout << "It ends at R" << std::endl;
        return 0;
    }

    // number of permutations and nodes to be traversed
    int k = p.size();
    int permutes = 1;
    for (int i = 1; i <= k; i++)
        permutes *= i;

    std::cout << "Permutations (expected) are: " << permutes << std::endl;

    int x = 0;

    // hold result
    std::vector<std::vector<int>> check(permutes, std::vector<int>(k+1));

    // sort original vector for positions
    std::sort(p.begin(), p.end());
    for (int i = 0; i < k; i++)
        std::cout << p[i] << "    ";
    std::cout << std::endl;

    // run for permutations and also calculate nodes
    do {
        // hold first node
        int t = (r - 1) / 3;

        // Loop until we reach the kth term
        for (int i = 0; i < k; i++) {
            t*= std::pow(2, p[i]);
            // for branchless branches and nodes
            if ((t - 1) % 9 == 0) {
                check[permutes - 1][i] = p[i];
                t = (t - 1) / 3;
                break;
            }
            // if wrong node comes in
            if ((t-1)%3 != 0) {
                check[permutes - 1][i] = p[i];
                break;
            }
            check[permutes - 1][i] = p[i];
            t = (t - 1) / 3;
        }

        check[permutes - 1][k] = t;         // Store the node
        check[permutes - 1][k + 1] = 0;     // add a 0 as separator
        permutes--;
    } while (std::next_permutation(p.begin(), p.end()));

    // remove the duplicates
    check.erase(std::unique(check.begin(), check.end()), check.end());

    return 0;
    int count = 0;      // count even results
    std::cout << "Start It" << std::endl;
    // check for base stem
    if ((r - 1) % 9 == 0 || (r-1)%3 != 0) {
        std::cout << "It ends at R" << std::endl;
        return 0;
    }

    // number of permutations and nodes to be traversed
    int k = p.size();
    int permutes = 1;
    for (int i = 1; i <= k; i++)
        permutes *= i;

    std::cout << "Permutations (expected) are: " << permutes << std::endl;
        //////////////////////////
    int x = 0;

    // hold result
    std::vector<std::vector<int>> check(permutes, std::vector<int>(k+1));

    // sort original vector for positions
    std::sort(p.begin(), p.end());
    for (int i = 0; i < k; i++)
        std::cout << p[i] << "    ";
    std::cout << std::endl;

    // run for permutations and also calculate nodes
    do {
        // hold first node
        int t = (r - 1) / 3;

        // Loop until we reach the kth term
        for (int i = 0; i < k; i++) {
            t*= std::pow(2, p[i]);
            // for branchless branches and nodes
            if ((t - 1) % 9 == 0) {
                check[permutes - 1][i] = p[i];
                t = (t - 1) / 3;
                break;
            }
            // if wrong node comes in
            if ((t-1)%3 != 0) {
                check[permutes - 1][i] = p[i];
                break;
            }
            check[permutes - 1][i] = p[i];
            t = (t - 1) / 3;
        }

        check[permutes-1][k] = t;

        if (check[permutes-1][k] % 2 == 0)
            count++;

        // print all values
        for (int i = 0; i < k + 1;i++) {
            std::cout << check[permutes - 1][i] << "    ";
        }
        std::cout << std::endl;

        permutes--;
        x++;
    } while (std::next_permutation(p.begin(), p.end()));

    std::cout << "Real Permutations are: " << x << std::endl;
    std::cout << "What an end! Even count is " << count << ". Proper Results are: " << (x-count) << std::endl;
    return 0;
}

